subgraph cluster_init_queue{
label = init_queue;
subgraph cluster_BB0{
label = BB0;
dataflow
"init_queue  %2 = alloca %struct.queue_t*, align 8" -> "init_queue  store %struct.queue_t* %0, %struct.queue_t** %2, align 8";
"init_queue  %2 = alloca %struct.queue_t*, align 8" -> "init_queue  %3 = load %struct.queue_t*, %struct.queue_t** %2, align 8";
"init_queue  %3 = load %struct.queue_t*, %struct.queue_t** %2, align 8" -> "init_queue  %4 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %3, i32 0, i32 0";
"init_queue  %4 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %3, i32 0, i32 0" -> "init_queue  store i32 0, i32* %4, align 4";
"init_queue  %2 = alloca %struct.queue_t*, align 8" -> "init_queue  %5 = load %struct.queue_t*, %struct.queue_t** %2, align 8";
"init_queue  %5 = load %struct.queue_t*, %struct.queue_t** %2, align 8" -> "init_queue  %6 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %5, i32 0, i32 1";
"init_queue  %6 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %5, i32 0, i32 1" -> "init_queue  store i32 254, i32* %6, align 4";
"init_queue  %2 = alloca %struct.queue_t*, align 8" -> "init_queue  %7 = load %struct.queue_t*, %struct.queue_t** %2, align 8";
"init_queue  %7 = load %struct.queue_t*, %struct.queue_t** %2, align 8" -> "init_queue  %8 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %7, i32 0, i32 3";
"init_queue  %8 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %7, i32 0, i32 3" -> "init_queue  store i32 0, i32* %8, align 4";
controlflow
"init_queue  %2 = alloca %struct.queue_t*, align 8" -> "init_queue  store %struct.queue_t* %0, %struct.queue_t** %2, align 8";
"init_queue  store %struct.queue_t* %0, %struct.queue_t** %2, align 8" -> "init_queue  %3 = load %struct.queue_t*, %struct.queue_t** %2, align 8";
"init_queue  %3 = load %struct.queue_t*, %struct.queue_t** %2, align 8" -> "init_queue  %4 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %3, i32 0, i32 0";
"init_queue  %4 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %3, i32 0, i32 0" -> "init_queue  store i32 0, i32* %4, align 4";
"init_queue  store i32 0, i32* %4, align 4" -> "init_queue  %5 = load %struct.queue_t*, %struct.queue_t** %2, align 8";
"init_queue  %5 = load %struct.queue_t*, %struct.queue_t** %2, align 8" -> "init_queue  %6 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %5, i32 0, i32 1";
"init_queue  %6 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %5, i32 0, i32 1" -> "init_queue  store i32 254, i32* %6, align 4";
"init_queue  store i32 254, i32* %6, align 4" -> "init_queue  %7 = load %struct.queue_t*, %struct.queue_t** %2, align 8";
"init_queue  %7 = load %struct.queue_t*, %struct.queue_t** %2, align 8" -> "init_queue  %8 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %7, i32 0, i32 3";
"init_queue  %8 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %7, i32 0, i32 3" -> "init_queue  store i32 0, i32* %8, align 4";
"init_queue  store i32 0, i32* %8, align 4" -> "init_queue  ret void";
};
};
subgraph cluster_push{
label = push;
subgraph cluster_BB1{
label = BB1;
dataflow
"push  %3 = alloca %struct.queue_t*, align 8" -> "push  store %struct.queue_t* %0, %struct.queue_t** %3, align 8";
"push  %4 = alloca i32, align 4" -> "push  store i32 %1, i32* %4, align 4";
"push  %3 = alloca %struct.queue_t*, align 8" -> "push  %5 = load %struct.queue_t*, %struct.queue_t** %3, align 8";
"push  %5 = load %struct.queue_t*, %struct.queue_t** %3, align 8" -> "push  %6 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %5, i32 0, i32 3";
"push  %6 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %5, i32 0, i32 3" -> "push  %7 = load i32, i32* %6, align 4";
"push  %7 = load i32, i32* %6, align 4" -> "push  %8 = icmp sge i32 %7, 255";
"push  %8 = icmp sge i32 %7, 255" -> "push1  br i1 %8, label %9, label %12";
controlflow
"push  %3 = alloca %struct.queue_t*, align 8" -> "push  %4 = alloca i32, align 4";
"push  %4 = alloca i32, align 4" -> "push  store %struct.queue_t* %0, %struct.queue_t** %3, align 8";
"push  store %struct.queue_t* %0, %struct.queue_t** %3, align 8" -> "push  store i32 %1, i32* %4, align 4";
"push  store i32 %1, i32* %4, align 4" -> "push  %5 = load %struct.queue_t*, %struct.queue_t** %3, align 8";
"push  %5 = load %struct.queue_t*, %struct.queue_t** %3, align 8" -> "push  %6 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %5, i32 0, i32 3";
"push  %6 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %5, i32 0, i32 3" -> "push  %7 = load i32, i32* %6, align 4";
"push  %7 = load i32, i32* %6, align 4" -> "push  %8 = icmp sge i32 %7, 255";
"push  %8 = icmp sge i32 %7, 255" -> "push1  br i1 %8, label %9, label %12";
};
subgraph cluster_BB2{
label = BB2;
dataflow
"push  %4 = alloca i32, align 4" -> "push  %10 = load i32, i32* %4, align 4";
"push  %10 = load i32, i32* %4, align 4" -> "push  %11 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str, i32 0, i32 0), i32 %10)";
"printf" -> "push  %11 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str, i32 0, i32 0), i32 %10)";
"printf" [ color = red ];
controlflow
"push  %10 = load i32, i32* %4, align 4" -> "push  %11 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str, i32 0, i32 0), i32 %10)";
"push  %11 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str, i32 0, i32 0), i32 %10)" -> "push2  br label %34";
};
subgraph cluster_BB3{
label = BB3;
dataflow
"push  %3 = alloca %struct.queue_t*, align 8" -> "push  %13 = load %struct.queue_t*, %struct.queue_t** %3, align 8";
"push  %13 = load %struct.queue_t*, %struct.queue_t** %3, align 8" -> "push  %14 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %13, i32 0, i32 1";
"push  %14 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %13, i32 0, i32 1" -> "push  %15 = load i32, i32* %14, align 4";
"push  %15 = load i32, i32* %14, align 4" -> "push  %16 = add nsw i32 %15, 1";
"push  %16 = add nsw i32 %15, 1" -> "push  %17 = srem i32 %16, 255";
"push  %3 = alloca %struct.queue_t*, align 8" -> "push  %18 = load %struct.queue_t*, %struct.queue_t** %3, align 8";
"push  %18 = load %struct.queue_t*, %struct.queue_t** %3, align 8" -> "push  %19 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %18, i32 0, i32 1";
"push  %17 = srem i32 %16, 255" -> "push  store i32 %17, i32* %19, align 4";
"push  %19 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %18, i32 0, i32 1" -> "push  store i32 %17, i32* %19, align 4";
"push  %4 = alloca i32, align 4" -> "push  %20 = load i32, i32* %4, align 4";
"push  %3 = alloca %struct.queue_t*, align 8" -> "push  %21 = load %struct.queue_t*, %struct.queue_t** %3, align 8";
"push  %21 = load %struct.queue_t*, %struct.queue_t** %3, align 8" -> "push  %22 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %21, i32 0, i32 2";
"push  %3 = alloca %struct.queue_t*, align 8" -> "push  %23 = load %struct.queue_t*, %struct.queue_t** %3, align 8";
"push  %23 = load %struct.queue_t*, %struct.queue_t** %3, align 8" -> "push  %24 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %23, i32 0, i32 1";
"push  %24 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %23, i32 0, i32 1" -> "push  %25 = load i32, i32* %24, align 4";
"push  %25 = load i32, i32* %24, align 4" -> "push  %26 = sext i32 %25 to i64";
"push  %22 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %21, i32 0, i32 2" -> "push  %27 = getelementptr inbounds [256 x i32], [256 x i32]* %22, i64 0, i64 %26";
"push  %26 = sext i32 %25 to i64" -> "push  %27 = getelementptr inbounds [256 x i32], [256 x i32]* %22, i64 0, i64 %26";
"push  %20 = load i32, i32* %4, align 4" -> "push  store i32 %20, i32* %27, align 4";
"push  %27 = getelementptr inbounds [256 x i32], [256 x i32]* %22, i64 0, i64 %26" -> "push  store i32 %20, i32* %27, align 4";
"push  %3 = alloca %struct.queue_t*, align 8" -> "push  %28 = load %struct.queue_t*, %struct.queue_t** %3, align 8";
"push  %28 = load %struct.queue_t*, %struct.queue_t** %3, align 8" -> "push  %29 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %28, i32 0, i32 3";
"push  %29 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %28, i32 0, i32 3" -> "push  %30 = load i32, i32* %29, align 4";
"push  %30 = load i32, i32* %29, align 4" -> "push  %31 = add nsw i32 %30, 1";
"push  %3 = alloca %struct.queue_t*, align 8" -> "push  %32 = load %struct.queue_t*, %struct.queue_t** %3, align 8";
"push  %32 = load %struct.queue_t*, %struct.queue_t** %3, align 8" -> "push  %33 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %32, i32 0, i32 3";
"push  %31 = add nsw i32 %30, 1" -> "push  store i32 %31, i32* %33, align 4";
"push  %33 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %32, i32 0, i32 3" -> "push  store i32 %31, i32* %33, align 4";
controlflow
"push  %13 = load %struct.queue_t*, %struct.queue_t** %3, align 8" -> "push  %14 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %13, i32 0, i32 1";
"push  %14 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %13, i32 0, i32 1" -> "push  %15 = load i32, i32* %14, align 4";
"push  %15 = load i32, i32* %14, align 4" -> "push  %16 = add nsw i32 %15, 1";
"push  %16 = add nsw i32 %15, 1" -> "push  %17 = srem i32 %16, 255";
"push  %17 = srem i32 %16, 255" -> "push  %18 = load %struct.queue_t*, %struct.queue_t** %3, align 8";
"push  %18 = load %struct.queue_t*, %struct.queue_t** %3, align 8" -> "push  %19 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %18, i32 0, i32 1";
"push  %19 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %18, i32 0, i32 1" -> "push  store i32 %17, i32* %19, align 4";
"push  store i32 %17, i32* %19, align 4" -> "push  %20 = load i32, i32* %4, align 4";
"push  %20 = load i32, i32* %4, align 4" -> "push  %21 = load %struct.queue_t*, %struct.queue_t** %3, align 8";
"push  %21 = load %struct.queue_t*, %struct.queue_t** %3, align 8" -> "push  %22 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %21, i32 0, i32 2";
"push  %22 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %21, i32 0, i32 2" -> "push  %23 = load %struct.queue_t*, %struct.queue_t** %3, align 8";
"push  %23 = load %struct.queue_t*, %struct.queue_t** %3, align 8" -> "push  %24 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %23, i32 0, i32 1";
"push  %24 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %23, i32 0, i32 1" -> "push  %25 = load i32, i32* %24, align 4";
"push  %25 = load i32, i32* %24, align 4" -> "push  %26 = sext i32 %25 to i64";
"push  %26 = sext i32 %25 to i64" -> "push  %27 = getelementptr inbounds [256 x i32], [256 x i32]* %22, i64 0, i64 %26";
"push  %27 = getelementptr inbounds [256 x i32], [256 x i32]* %22, i64 0, i64 %26" -> "push  store i32 %20, i32* %27, align 4";
"push  store i32 %20, i32* %27, align 4" -> "push  %28 = load %struct.queue_t*, %struct.queue_t** %3, align 8";
"push  %28 = load %struct.queue_t*, %struct.queue_t** %3, align 8" -> "push  %29 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %28, i32 0, i32 3";
"push  %29 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %28, i32 0, i32 3" -> "push  %30 = load i32, i32* %29, align 4";
"push  %30 = load i32, i32* %29, align 4" -> "push  %31 = add nsw i32 %30, 1";
"push  %31 = add nsw i32 %30, 1" -> "push  %32 = load %struct.queue_t*, %struct.queue_t** %3, align 8";
"push  %32 = load %struct.queue_t*, %struct.queue_t** %3, align 8" -> "push  %33 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %32, i32 0, i32 3";
"push  %33 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %32, i32 0, i32 3" -> "push  store i32 %31, i32* %33, align 4";
"push  store i32 %31, i32* %33, align 4" -> "push3  br label %34";
};
subgraph cluster_BB4{
label = BB4;
dataflow
controlflow
"push  ret void";
};
};
subgraph cluster_front{
label = front;
subgraph cluster_BB5{
label = BB5;
dataflow
"front  %2 = alloca %struct.queue_t*, align 8" -> "front  store %struct.queue_t* %0, %struct.queue_t** %2, align 8";
"front  %2 = alloca %struct.queue_t*, align 8" -> "front  %4 = load %struct.queue_t*, %struct.queue_t** %2, align 8";
"front  %4 = load %struct.queue_t*, %struct.queue_t** %2, align 8" -> "front  %5 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %4, i32 0, i32 3";
"front  %5 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %4, i32 0, i32 3" -> "front  %6 = load i32, i32* %5, align 4";
"front  %6 = load i32, i32* %5, align 4" -> "front  %7 = icmp sle i32 %6, 0";
"front  %7 = icmp sle i32 %6, 0" -> "front5  br i1 %7, label %8, label %10";
controlflow
"front  %2 = alloca %struct.queue_t*, align 8" -> "front  %3 = alloca i32, align 4";
"front  %3 = alloca i32, align 4" -> "front  store %struct.queue_t* %0, %struct.queue_t** %2, align 8";
"front  store %struct.queue_t* %0, %struct.queue_t** %2, align 8" -> "front  %4 = load %struct.queue_t*, %struct.queue_t** %2, align 8";
"front  %4 = load %struct.queue_t*, %struct.queue_t** %2, align 8" -> "front  %5 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %4, i32 0, i32 3";
"front  %5 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %4, i32 0, i32 3" -> "front  %6 = load i32, i32* %5, align 4";
"front  %6 = load i32, i32* %5, align 4" -> "front  %7 = icmp sle i32 %6, 0";
"front  %7 = icmp sle i32 %6, 0" -> "front5  br i1 %7, label %8, label %10";
};
subgraph cluster_BB6{
label = BB6;
dataflow
"printf" -> "front  %9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.1, i32 0, i32 0))";
"printf" [ color = red ];
controlflow
"front  %9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.1, i32 0, i32 0))" -> "front6  br label %19";
};
subgraph cluster_BB7{
label = BB7;
dataflow
"front  %2 = alloca %struct.queue_t*, align 8" -> "front  %11 = load %struct.queue_t*, %struct.queue_t** %2, align 8";
"front  %11 = load %struct.queue_t*, %struct.queue_t** %2, align 8" -> "front  %12 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %11, i32 0, i32 2";
"front  %2 = alloca %struct.queue_t*, align 8" -> "front  %13 = load %struct.queue_t*, %struct.queue_t** %2, align 8";
"front  %13 = load %struct.queue_t*, %struct.queue_t** %2, align 8" -> "front  %14 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %13, i32 0, i32 0";
"front  %14 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %13, i32 0, i32 0" -> "front  %15 = load i32, i32* %14, align 4";
"front  %15 = load i32, i32* %14, align 4" -> "front  %16 = sext i32 %15 to i64";
"front  %12 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %11, i32 0, i32 2" -> "front  %17 = getelementptr inbounds [256 x i32], [256 x i32]* %12, i64 0, i64 %16";
"front  %16 = sext i32 %15 to i64" -> "front  %17 = getelementptr inbounds [256 x i32], [256 x i32]* %12, i64 0, i64 %16";
"front  %17 = getelementptr inbounds [256 x i32], [256 x i32]* %12, i64 0, i64 %16" -> "front  %18 = load i32, i32* %17, align 4";
"front  %18 = load i32, i32* %17, align 4" -> "front  store i32 %18, i32* %3, align 4";
"front  %3 = alloca i32, align 4" -> "front  store i32 %18, i32* %3, align 4";
controlflow
"front  %11 = load %struct.queue_t*, %struct.queue_t** %2, align 8" -> "front  %12 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %11, i32 0, i32 2";
"front  %12 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %11, i32 0, i32 2" -> "front  %13 = load %struct.queue_t*, %struct.queue_t** %2, align 8";
"front  %13 = load %struct.queue_t*, %struct.queue_t** %2, align 8" -> "front  %14 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %13, i32 0, i32 0";
"front  %14 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %13, i32 0, i32 0" -> "front  %15 = load i32, i32* %14, align 4";
"front  %15 = load i32, i32* %14, align 4" -> "front  %16 = sext i32 %15 to i64";
"front  %16 = sext i32 %15 to i64" -> "front  %17 = getelementptr inbounds [256 x i32], [256 x i32]* %12, i64 0, i64 %16";
"front  %17 = getelementptr inbounds [256 x i32], [256 x i32]* %12, i64 0, i64 %16" -> "front  %18 = load i32, i32* %17, align 4";
"front  %18 = load i32, i32* %17, align 4" -> "front  store i32 %18, i32* %3, align 4";
"front  store i32 %18, i32* %3, align 4" -> "front7  br label %19";
};
subgraph cluster_BB8{
label = BB8;
dataflow
"front  %3 = alloca i32, align 4" -> "front  %20 = load i32, i32* %3, align 4";
"front  %20 = load i32, i32* %3, align 4" -> "front  ret i32 %20";
controlflow
"front  %20 = load i32, i32* %3, align 4" -> "front  ret i32 %20";
};
};
subgraph cluster_back{
label = back;
subgraph cluster_BB9{
label = BB9;
dataflow
"back  %2 = alloca %struct.queue_t*, align 8" -> "back  store %struct.queue_t* %0, %struct.queue_t** %2, align 8";
"back  %2 = alloca %struct.queue_t*, align 8" -> "back  %4 = load %struct.queue_t*, %struct.queue_t** %2, align 8";
"back  %4 = load %struct.queue_t*, %struct.queue_t** %2, align 8" -> "back  %5 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %4, i32 0, i32 3";
"back  %5 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %4, i32 0, i32 3" -> "back  %6 = load i32, i32* %5, align 4";
"back  %6 = load i32, i32* %5, align 4" -> "back  %7 = icmp sge i32 %6, 255";
"back  %7 = icmp sge i32 %6, 255" -> "back9  br i1 %7, label %8, label %10";
controlflow
"back  %2 = alloca %struct.queue_t*, align 8" -> "back  %3 = alloca i32, align 4";
"back  %3 = alloca i32, align 4" -> "back  store %struct.queue_t* %0, %struct.queue_t** %2, align 8";
"back  store %struct.queue_t* %0, %struct.queue_t** %2, align 8" -> "back  %4 = load %struct.queue_t*, %struct.queue_t** %2, align 8";
"back  %4 = load %struct.queue_t*, %struct.queue_t** %2, align 8" -> "back  %5 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %4, i32 0, i32 3";
"back  %5 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %4, i32 0, i32 3" -> "back  %6 = load i32, i32* %5, align 4";
"back  %6 = load i32, i32* %5, align 4" -> "back  %7 = icmp sge i32 %6, 255";
"back  %7 = icmp sge i32 %6, 255" -> "back9  br i1 %7, label %8, label %10";
};
subgraph cluster_BB10{
label = BB10;
dataflow
"printf" -> "back  %9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.2, i32 0, i32 0))";
"printf" [ color = red ];
controlflow
"back  %9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.2, i32 0, i32 0))" -> "back10  br label %19";
};
subgraph cluster_BB11{
label = BB11;
dataflow
"back  %2 = alloca %struct.queue_t*, align 8" -> "back  %11 = load %struct.queue_t*, %struct.queue_t** %2, align 8";
"back  %11 = load %struct.queue_t*, %struct.queue_t** %2, align 8" -> "back  %12 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %11, i32 0, i32 2";
"back  %2 = alloca %struct.queue_t*, align 8" -> "back  %13 = load %struct.queue_t*, %struct.queue_t** %2, align 8";
"back  %13 = load %struct.queue_t*, %struct.queue_t** %2, align 8" -> "back  %14 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %13, i32 0, i32 1";
"back  %14 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %13, i32 0, i32 1" -> "back  %15 = load i32, i32* %14, align 4";
"back  %15 = load i32, i32* %14, align 4" -> "back  %16 = sext i32 %15 to i64";
"back  %12 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %11, i32 0, i32 2" -> "back  %17 = getelementptr inbounds [256 x i32], [256 x i32]* %12, i64 0, i64 %16";
"back  %16 = sext i32 %15 to i64" -> "back  %17 = getelementptr inbounds [256 x i32], [256 x i32]* %12, i64 0, i64 %16";
"back  %17 = getelementptr inbounds [256 x i32], [256 x i32]* %12, i64 0, i64 %16" -> "back  %18 = load i32, i32* %17, align 4";
"back  %18 = load i32, i32* %17, align 4" -> "back  store i32 %18, i32* %3, align 4";
"back  %3 = alloca i32, align 4" -> "back  store i32 %18, i32* %3, align 4";
controlflow
"back  %11 = load %struct.queue_t*, %struct.queue_t** %2, align 8" -> "back  %12 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %11, i32 0, i32 2";
"back  %12 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %11, i32 0, i32 2" -> "back  %13 = load %struct.queue_t*, %struct.queue_t** %2, align 8";
"back  %13 = load %struct.queue_t*, %struct.queue_t** %2, align 8" -> "back  %14 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %13, i32 0, i32 1";
"back  %14 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %13, i32 0, i32 1" -> "back  %15 = load i32, i32* %14, align 4";
"back  %15 = load i32, i32* %14, align 4" -> "back  %16 = sext i32 %15 to i64";
"back  %16 = sext i32 %15 to i64" -> "back  %17 = getelementptr inbounds [256 x i32], [256 x i32]* %12, i64 0, i64 %16";
"back  %17 = getelementptr inbounds [256 x i32], [256 x i32]* %12, i64 0, i64 %16" -> "back  %18 = load i32, i32* %17, align 4";
"back  %18 = load i32, i32* %17, align 4" -> "back  store i32 %18, i32* %3, align 4";
"back  store i32 %18, i32* %3, align 4" -> "back11  br label %19";
};
subgraph cluster_BB12{
label = BB12;
dataflow
"back  %3 = alloca i32, align 4" -> "back  %20 = load i32, i32* %3, align 4";
"back  %20 = load i32, i32* %3, align 4" -> "back  ret i32 %20";
controlflow
"back  %20 = load i32, i32* %3, align 4" -> "back  ret i32 %20";
};
};
subgraph cluster_pop{
label = pop;
subgraph cluster_BB13{
label = BB13;
dataflow
"pop  %2 = alloca %struct.queue_t*, align 8" -> "pop  store %struct.queue_t* %0, %struct.queue_t** %2, align 8";
"pop  %2 = alloca %struct.queue_t*, align 8" -> "pop  %3 = load %struct.queue_t*, %struct.queue_t** %2, align 8";
"pop  %3 = load %struct.queue_t*, %struct.queue_t** %2, align 8" -> "pop  %4 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %3, i32 0, i32 0";
"pop  %4 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %3, i32 0, i32 0" -> "pop  %5 = load i32, i32* %4, align 4";
"pop  %5 = load i32, i32* %4, align 4" -> "pop  %6 = add nsw i32 %5, 1";
"pop  %6 = add nsw i32 %5, 1" -> "pop  %7 = srem i32 %6, 255";
"pop  %2 = alloca %struct.queue_t*, align 8" -> "pop  %8 = load %struct.queue_t*, %struct.queue_t** %2, align 8";
"pop  %8 = load %struct.queue_t*, %struct.queue_t** %2, align 8" -> "pop  %9 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %8, i32 0, i32 0";
"pop  %7 = srem i32 %6, 255" -> "pop  store i32 %7, i32* %9, align 4";
"pop  %9 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %8, i32 0, i32 0" -> "pop  store i32 %7, i32* %9, align 4";
"pop  %2 = alloca %struct.queue_t*, align 8" -> "pop  %10 = load %struct.queue_t*, %struct.queue_t** %2, align 8";
"pop  %10 = load %struct.queue_t*, %struct.queue_t** %2, align 8" -> "pop  %11 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %10, i32 0, i32 3";
"pop  %11 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %10, i32 0, i32 3" -> "pop  %12 = load i32, i32* %11, align 4";
"pop  %12 = load i32, i32* %11, align 4" -> "pop  %13 = sub nsw i32 %12, 1";
"pop  %2 = alloca %struct.queue_t*, align 8" -> "pop  %14 = load %struct.queue_t*, %struct.queue_t** %2, align 8";
"pop  %14 = load %struct.queue_t*, %struct.queue_t** %2, align 8" -> "pop  %15 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %14, i32 0, i32 3";
"pop  %13 = sub nsw i32 %12, 1" -> "pop  store i32 %13, i32* %15, align 4";
"pop  %15 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %14, i32 0, i32 3" -> "pop  store i32 %13, i32* %15, align 4";
controlflow
"pop  %2 = alloca %struct.queue_t*, align 8" -> "pop  store %struct.queue_t* %0, %struct.queue_t** %2, align 8";
"pop  store %struct.queue_t* %0, %struct.queue_t** %2, align 8" -> "pop  %3 = load %struct.queue_t*, %struct.queue_t** %2, align 8";
"pop  %3 = load %struct.queue_t*, %struct.queue_t** %2, align 8" -> "pop  %4 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %3, i32 0, i32 0";
"pop  %4 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %3, i32 0, i32 0" -> "pop  %5 = load i32, i32* %4, align 4";
"pop  %5 = load i32, i32* %4, align 4" -> "pop  %6 = add nsw i32 %5, 1";
"pop  %6 = add nsw i32 %5, 1" -> "pop  %7 = srem i32 %6, 255";
"pop  %7 = srem i32 %6, 255" -> "pop  %8 = load %struct.queue_t*, %struct.queue_t** %2, align 8";
"pop  %8 = load %struct.queue_t*, %struct.queue_t** %2, align 8" -> "pop  %9 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %8, i32 0, i32 0";
"pop  %9 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %8, i32 0, i32 0" -> "pop  store i32 %7, i32* %9, align 4";
"pop  store i32 %7, i32* %9, align 4" -> "pop  %10 = load %struct.queue_t*, %struct.queue_t** %2, align 8";
"pop  %10 = load %struct.queue_t*, %struct.queue_t** %2, align 8" -> "pop  %11 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %10, i32 0, i32 3";
"pop  %11 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %10, i32 0, i32 3" -> "pop  %12 = load i32, i32* %11, align 4";
"pop  %12 = load i32, i32* %11, align 4" -> "pop  %13 = sub nsw i32 %12, 1";
"pop  %13 = sub nsw i32 %12, 1" -> "pop  %14 = load %struct.queue_t*, %struct.queue_t** %2, align 8";
"pop  %14 = load %struct.queue_t*, %struct.queue_t** %2, align 8" -> "pop  %15 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %14, i32 0, i32 3";
"pop  %15 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %14, i32 0, i32 3" -> "pop  store i32 %13, i32* %15, align 4";
"pop  store i32 %13, i32* %15, align 4" -> "pop  ret void";
};
};
subgraph cluster_is_empty{
label = is_empty;
subgraph cluster_BB14{
label = BB14;
dataflow
"is_empty  %3 = alloca %struct.queue_t*, align 8" -> "is_empty  store %struct.queue_t* %0, %struct.queue_t** %3, align 8";
"is_empty  %3 = alloca %struct.queue_t*, align 8" -> "is_empty  %4 = load %struct.queue_t*, %struct.queue_t** %3, align 8";
"is_empty  %4 = load %struct.queue_t*, %struct.queue_t** %3, align 8" -> "is_empty  %5 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %4, i32 0, i32 3";
"is_empty  %5 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %4, i32 0, i32 3" -> "is_empty  %6 = load i32, i32* %5, align 4";
"is_empty  %6 = load i32, i32* %5, align 4" -> "is_empty  %7 = icmp sle i32 %6, 0";
"is_empty  %7 = icmp sle i32 %6, 0" -> "is_empty14  br i1 %7, label %8, label %9";
controlflow
"is_empty  %2 = alloca i32, align 4" -> "is_empty  %3 = alloca %struct.queue_t*, align 8";
"is_empty  %3 = alloca %struct.queue_t*, align 8" -> "is_empty  store %struct.queue_t* %0, %struct.queue_t** %3, align 8";
"is_empty  store %struct.queue_t* %0, %struct.queue_t** %3, align 8" -> "is_empty  %4 = load %struct.queue_t*, %struct.queue_t** %3, align 8";
"is_empty  %4 = load %struct.queue_t*, %struct.queue_t** %3, align 8" -> "is_empty  %5 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %4, i32 0, i32 3";
"is_empty  %5 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %4, i32 0, i32 3" -> "is_empty  %6 = load i32, i32* %5, align 4";
"is_empty  %6 = load i32, i32* %5, align 4" -> "is_empty  %7 = icmp sle i32 %6, 0";
"is_empty  %7 = icmp sle i32 %6, 0" -> "is_empty14  br i1 %7, label %8, label %9";
};
subgraph cluster_BB15{
label = BB15;
dataflow
"is_empty  %2 = alloca i32, align 4" -> "is_empty  store i32 1, i32* %2, align 4";
controlflow
"is_empty  store i32 1, i32* %2, align 4" -> "is_empty15  br label %10";
};
subgraph cluster_BB16{
label = BB16;
dataflow
"is_empty  %2 = alloca i32, align 4" -> "is_empty  store i32 0, i32* %2, align 4";
controlflow
"is_empty  store i32 0, i32* %2, align 4" -> "is_empty16  br label %10";
};
subgraph cluster_BB17{
label = BB17;
dataflow
"is_empty  %2 = alloca i32, align 4" -> "is_empty  %11 = load i32, i32* %2, align 4";
"is_empty  %11 = load i32, i32* %2, align 4" -> "is_empty  ret i32 %11";
controlflow
"is_empty  %11 = load i32, i32* %2, align 4" -> "is_empty  ret i32 %11";
};
};
subgraph cluster_main{
label = main;
subgraph cluster_BB18{
label = BB18;
dataflow
"main  %1 = alloca i32, align 4" -> "main  store i32 0, i32* %1, align 4";
"main  %4 = alloca %struct.queue_t, align 4" -> "main  call void @init_queue(%struct.queue_t* %4)";
"init_queue" -> "main  call void @init_queue(%struct.queue_t* %4)";
"init_queue" [ color = red ];
"main  %4 = alloca %struct.queue_t, align 4" -> "main  call void @push(%struct.queue_t* %4, i32 0)";
"push" -> "main  call void @push(%struct.queue_t* %4, i32 0)";
"push" [ color = red ];
controlflow
"main  %1 = alloca i32, align 4" -> "main  %2 = alloca i32, align 4";
"main  %2 = alloca i32, align 4" -> "main  %3 = alloca i32, align 4";
"main  %3 = alloca i32, align 4" -> "main  %4 = alloca %struct.queue_t, align 4";
"main  %4 = alloca %struct.queue_t, align 4" -> "main  store i32 0, i32* %1, align 4";
"main  store i32 0, i32* %1, align 4" -> "main  call void @init_queue(%struct.queue_t* %4)";
"main  call void @init_queue(%struct.queue_t* %4)" -> "main  call void @push(%struct.queue_t* %4, i32 0)";
"main  call void @push(%struct.queue_t* %4, i32 0)" -> "main18  br label %5";
};
subgraph cluster_BB19{
label = BB19;
dataflow
"main  %4 = alloca %struct.queue_t, align 4" -> "main  %6 = call i32 @is_empty(%struct.queue_t* %4)";
"is_empty" -> "main  %6 = call i32 @is_empty(%struct.queue_t* %4)";
"is_empty" [ color = red ];
"main  %6 = call i32 @is_empty(%struct.queue_t* %4)" -> "main  %7 = icmp eq i32 %6, 0";
"main  %7 = icmp eq i32 %6, 0" -> "main19  br i1 %7, label %8, label %36";
controlflow
"main  %6 = call i32 @is_empty(%struct.queue_t* %4)" -> "main  %7 = icmp eq i32 %6, 0";
"main  %7 = icmp eq i32 %6, 0" -> "main19  br i1 %7, label %8, label %36";
};
subgraph cluster_BB20{
label = BB20;
dataflow
"main  %4 = alloca %struct.queue_t, align 4" -> "main  %9 = call i32 @front(%struct.queue_t* %4)";
"front" -> "main  %9 = call i32 @front(%struct.queue_t* %4)";
"front" [ color = red ];
"main  %9 = call i32 @front(%struct.queue_t* %4)" -> "main  store i32 %9, i32* %3, align 4";
"main  %3 = alloca i32, align 4" -> "main  store i32 %9, i32* %3, align 4";
"main  %3 = alloca i32, align 4" -> "main  %10 = load i32, i32* %3, align 4";
"main  %10 = load i32, i32* %3, align 4" -> "main  %11 = add nsw i32 %10, 1";
"main  %4 = alloca %struct.queue_t, align 4" -> "main  %12 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %4, i32 0, i32 0";
"main  %12 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %4, i32 0, i32 0" -> "main  %13 = load i32, i32* %12, align 4";
"main  %4 = alloca %struct.queue_t, align 4" -> "main  %14 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %4, i32 0, i32 1";
"main  %14 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %4, i32 0, i32 1" -> "main  %15 = load i32, i32* %14, align 4";
"main  %11 = add nsw i32 %10, 1" -> "main  %16 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.3, i32 0, i32 0), i32 %11, i32 %13, i32 %15)";
"main  %13 = load i32, i32* %12, align 4" -> "main  %16 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.3, i32 0, i32 0), i32 %11, i32 %13, i32 %15)";
"main  %15 = load i32, i32* %14, align 4" -> "main  %16 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.3, i32 0, i32 0), i32 %11, i32 %13, i32 %15)";
"printf" -> "main  %16 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.3, i32 0, i32 0), i32 %11, i32 %13, i32 %15)";
"printf" [ color = red ];
"main  %4 = alloca %struct.queue_t, align 4" -> "main  call void @pop(%struct.queue_t* %4)";
"pop" -> "main  call void @pop(%struct.queue_t* %4)";
"pop" [ color = red ];
"main  %2 = alloca i32, align 4" -> "main  store i32 5, i32* %2, align 4";
controlflow
"main  %9 = call i32 @front(%struct.queue_t* %4)" -> "main  store i32 %9, i32* %3, align 4";
"main  store i32 %9, i32* %3, align 4" -> "main  %10 = load i32, i32* %3, align 4";
"main  %10 = load i32, i32* %3, align 4" -> "main  %11 = add nsw i32 %10, 1";
"main  %11 = add nsw i32 %10, 1" -> "main  %12 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %4, i32 0, i32 0";
"main  %12 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %4, i32 0, i32 0" -> "main  %13 = load i32, i32* %12, align 4";
"main  %13 = load i32, i32* %12, align 4" -> "main  %14 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %4, i32 0, i32 1";
"main  %14 = getelementptr inbounds %struct.queue_t, %struct.queue_t* %4, i32 0, i32 1" -> "main  %15 = load i32, i32* %14, align 4";
"main  %15 = load i32, i32* %14, align 4" -> "main  %16 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.3, i32 0, i32 0), i32 %11, i32 %13, i32 %15)";
"main  %16 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.3, i32 0, i32 0), i32 %11, i32 %13, i32 %15)" -> "main  call void @pop(%struct.queue_t* %4)";
"main  call void @pop(%struct.queue_t* %4)" -> "main  store i32 5, i32* %2, align 4";
"main  store i32 5, i32* %2, align 4" -> "main20  br label %17";
};
subgraph cluster_BB22{
label = BB22;
dataflow
"main  %2 = alloca i32, align 4" -> "main  %18 = load i32, i32* %2, align 4";
"main  %18 = load i32, i32* %2, align 4" -> "main  %19 = icmp sge i32 %18, 0";
"main  %19 = icmp sge i32 %18, 0" -> "main22  br i1 %19, label %20, label %35";
controlflow
"main  %18 = load i32, i32* %2, align 4" -> "main  %19 = icmp sge i32 %18, 0";
"main  %19 = icmp sge i32 %18, 0" -> "main22  br i1 %19, label %20, label %35";
};
subgraph cluster_BB23{
label = BB23;
dataflow
"main  %3 = alloca i32, align 4" -> "main  %21 = load i32, i32* %3, align 4";
"main  %21 = load i32, i32* %3, align 4" -> "main  %22 = sext i32 %21 to i64";
"grph" -> "main  %23 = getelementptr inbounds [6 x [6 x i32]], [6 x [6 x i32]]* @grph, i64 0, i64 %22";
"grph" [ color = red ];
"main  %22 = sext i32 %21 to i64" -> "main  %23 = getelementptr inbounds [6 x [6 x i32]], [6 x [6 x i32]]* @grph, i64 0, i64 %22";
"main  %2 = alloca i32, align 4" -> "main  %24 = load i32, i32* %2, align 4";
"main  %24 = load i32, i32* %2, align 4" -> "main  %25 = sext i32 %24 to i64";
"main  %23 = getelementptr inbounds [6 x [6 x i32]], [6 x [6 x i32]]* @grph, i64 0, i64 %22" -> "main  %26 = getelementptr inbounds [6 x i32], [6 x i32]* %23, i64 0, i64 %25";
"main  %25 = sext i32 %24 to i64" -> "main  %26 = getelementptr inbounds [6 x i32], [6 x i32]* %23, i64 0, i64 %25";
"main  %26 = getelementptr inbounds [6 x i32], [6 x i32]* %23, i64 0, i64 %25" -> "main  %27 = load i32, i32* %26, align 4";
"main  %27 = load i32, i32* %26, align 4" -> "main  %28 = icmp eq i32 %27, 1";
"main  %28 = icmp eq i32 %27, 1" -> "main23  br i1 %28, label %29, label %31";
controlflow
"main  %21 = load i32, i32* %3, align 4" -> "main  %22 = sext i32 %21 to i64";
"main  %22 = sext i32 %21 to i64" -> "main  %23 = getelementptr inbounds [6 x [6 x i32]], [6 x [6 x i32]]* @grph, i64 0, i64 %22";
"main  %23 = getelementptr inbounds [6 x [6 x i32]], [6 x [6 x i32]]* @grph, i64 0, i64 %22" -> "main  %24 = load i32, i32* %2, align 4";
"main  %24 = load i32, i32* %2, align 4" -> "main  %25 = sext i32 %24 to i64";
"main  %25 = sext i32 %24 to i64" -> "main  %26 = getelementptr inbounds [6 x i32], [6 x i32]* %23, i64 0, i64 %25";
"main  %26 = getelementptr inbounds [6 x i32], [6 x i32]* %23, i64 0, i64 %25" -> "main  %27 = load i32, i32* %26, align 4";
"main  %27 = load i32, i32* %26, align 4" -> "main  %28 = icmp eq i32 %27, 1";
"main  %28 = icmp eq i32 %27, 1" -> "main23  br i1 %28, label %29, label %31";
};
subgraph cluster_BB25{
label = BB25;
dataflow
"main  %2 = alloca i32, align 4" -> "main  %30 = load i32, i32* %2, align 4";
"main  %4 = alloca %struct.queue_t, align 4" -> "main  call void @push(%struct.queue_t* %4, i32 %30)";
"main  %30 = load i32, i32* %2, align 4" -> "main  call void @push(%struct.queue_t* %4, i32 %30)";
"push" -> "main  call void @push(%struct.queue_t* %4, i32 %30)";
"push" [ color = red ];
controlflow
"main  %30 = load i32, i32* %2, align 4" -> "main  call void @push(%struct.queue_t* %4, i32 %30)";
"main  call void @push(%struct.queue_t* %4, i32 %30)" -> "main25  br label %31";
};
subgraph cluster_BB26{
label = BB26;
dataflow
controlflow
"main26  br label %32";
};
subgraph cluster_BB27{
label = BB27;
dataflow
"main  %2 = alloca i32, align 4" -> "main  %33 = load i32, i32* %2, align 4";
"main  %33 = load i32, i32* %2, align 4" -> "main  %34 = add nsw i32 %33, -1";
"main  %34 = add nsw i32 %33, -1" -> "main  store i32 %34, i32* %2, align 4";
"main  %2 = alloca i32, align 4" -> "main  store i32 %34, i32* %2, align 4";
controlflow
"main  %33 = load i32, i32* %2, align 4" -> "main  %34 = add nsw i32 %33, -1";
"main  %34 = add nsw i32 %33, -1" -> "main  store i32 %34, i32* %2, align 4";
"main  store i32 %34, i32* %2, align 4" -> "main27  br label %17";
};
subgraph cluster_BB24{
label = BB24;
dataflow
controlflow
"main24  br label %5";
};
subgraph cluster_BB21{
label = BB21;
dataflow
controlflow
"main  ret i32 0";
};
};
bb_call
"main18  br label %5"-> "main  %6 = call i32 @is_empty(%struct.queue_t* %4)";[ltail = cluster_BB18 lhead = cluster_BB19];
"push1  br i1 %8, label %9, label %12"-> "push  %10 = load i32, i32* %4, align 4";[ltail = cluster_BB1 lhead = cluster_BB2];
"push1  br i1 %8, label %9, label %12"-> "push  %13 = load %struct.queue_t*, %struct.queue_t** %3, align 8";[ltail = cluster_BB1 lhead = cluster_BB3];
"push2  br label %34"-> "push  ret void";[ltail = cluster_BB2 lhead = cluster_BB4];
"push3  br label %34"-> "push  ret void";[ltail = cluster_BB3 lhead = cluster_BB4];
"front5  br i1 %7, label %8, label %10"-> "front  %9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.1, i32 0, i32 0))";[ltail = cluster_BB5 lhead = cluster_BB6];
"front5  br i1 %7, label %8, label %10"-> "front  %11 = load %struct.queue_t*, %struct.queue_t** %2, align 8";[ltail = cluster_BB5 lhead = cluster_BB7];
"front6  br label %19"-> "front  %20 = load i32, i32* %3, align 4";[ltail = cluster_BB6 lhead = cluster_BB8];
"front7  br label %19"-> "front  %20 = load i32, i32* %3, align 4";[ltail = cluster_BB7 lhead = cluster_BB8];
"back9  br i1 %7, label %8, label %10"-> "back  %9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.2, i32 0, i32 0))";[ltail = cluster_BB9 lhead = cluster_BB10];
"back9  br i1 %7, label %8, label %10"-> "back  %11 = load %struct.queue_t*, %struct.queue_t** %2, align 8";[ltail = cluster_BB9 lhead = cluster_BB11];
"back10  br label %19"-> "back  %20 = load i32, i32* %3, align 4";[ltail = cluster_BB10 lhead = cluster_BB12];
"back11  br label %19"-> "back  %20 = load i32, i32* %3, align 4";[ltail = cluster_BB11 lhead = cluster_BB12];
"is_empty14  br i1 %7, label %8, label %9"-> "is_empty  store i32 1, i32* %2, align 4";[ltail = cluster_BB14 lhead = cluster_BB15];
"is_empty14  br i1 %7, label %8, label %9"-> "is_empty  store i32 0, i32* %2, align 4";[ltail = cluster_BB14 lhead = cluster_BB16];
"is_empty15  br label %10"-> "is_empty  %11 = load i32, i32* %2, align 4";[ltail = cluster_BB15 lhead = cluster_BB17];
"is_empty16  br label %10"-> "is_empty  %11 = load i32, i32* %2, align 4";[ltail = cluster_BB16 lhead = cluster_BB17];
"main19  br i1 %7, label %8, label %36"-> "main  %9 = call i32 @front(%struct.queue_t* %4)";[ltail = cluster_BB19 lhead = cluster_BB20];
"main19  br i1 %7, label %8, label %36"-> "main  ret i32 0";[ltail = cluster_BB19 lhead = cluster_BB21];
"main20  br label %17"-> "main  %18 = load i32, i32* %2, align 4";[ltail = cluster_BB20 lhead = cluster_BB22];
"main22  br i1 %19, label %20, label %35"-> "main  %21 = load i32, i32* %3, align 4";[ltail = cluster_BB22 lhead = cluster_BB23];
"main22  br i1 %19, label %20, label %35"-> "main24  br label %5";[ltail = cluster_BB22 lhead = cluster_BB24];
"main23  br i1 %28, label %29, label %31"-> "main  %30 = load i32, i32* %2, align 4";[ltail = cluster_BB23 lhead = cluster_BB25];
"main23  br i1 %28, label %29, label %31"-> "main26  br label %32";[ltail = cluster_BB23 lhead = cluster_BB26];
"main24  br label %5"-> "main  %6 = call i32 @is_empty(%struct.queue_t* %4)";[ltail = cluster_BB24 lhead = cluster_BB19];
"main25  br label %31"-> "main26  br label %32";[ltail = cluster_BB25 lhead = cluster_BB26];
"main26  br label %32"-> "main  %33 = load i32, i32* %2, align 4";[ltail = cluster_BB26 lhead = cluster_BB27];
"main27  br label %17"-> "main  %18 = load i32, i32* %2, align 4";[ltail = cluster_BB27 lhead = cluster_BB22];
fun_call
"main  call void @init_queue(%struct.queue_t* %4)"-> "init_queue  %2 = alloca %struct.queue_t*, align 8";[lhead = cluster_BB0];
"init_queue  ret void"-> "main  call void @init_queue(%struct.queue_t* %4)";[lhead = cluster_BB0];
"main  call void @push(%struct.queue_t* %4, i32 0)"-> "push  %3 = alloca %struct.queue_t*, align 8";[lhead = cluster_BB1];
"push  ret void"-> "main  call void @push(%struct.queue_t* %4, i32 0)";[lhead = cluster_BB1];
"main  %6 = call i32 @is_empty(%struct.queue_t* %4)"-> "is_empty  %2 = alloca i32, align 4";[lhead = cluster_BB14];
"is_empty  ret i32 %11"-> "main  %6 = call i32 @is_empty(%struct.queue_t* %4)";[lhead = cluster_BB14];
"main  call void @pop(%struct.queue_t* %4)"-> "pop  %2 = alloca %struct.queue_t*, align 8";[lhead = cluster_BB13];
"pop  ret void"-> "main  call void @pop(%struct.queue_t* %4)";[lhead = cluster_BB13];
"main  %9 = call i32 @front(%struct.queue_t* %4)"-> "front  %2 = alloca %struct.queue_t*, align 8";[lhead = cluster_BB5];
"front  ret i32 %20"-> "main  %9 = call i32 @front(%struct.queue_t* %4)";[lhead = cluster_BB5];
"main  call void @push(%struct.queue_t* %4, i32 %30)"-> "push  %3 = alloca %struct.queue_t*, align 8";[lhead = cluster_BB1];
"push  ret void"-> "main  call void @push(%struct.queue_t* %4, i32 %30)";[lhead = cluster_BB1];
